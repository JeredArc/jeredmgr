#!/bin/bash

# Configuration
PROJECTS_DIR="./projects"           # projects directory, folder where all .env files live
SELFUPDATE_URL="https://raw.githubusercontent.com/JeredArc/jeredmgr/main/jeredmgr.sh"   # URL to the manager.sh file (must be publicly accessible)
PAT_FILE="./global-pat.txt"         # file where the global GitHub PAT is stored
LOG_LINES=10                        # how many log lines to show with log by default when showing logs for all projects
DEFAULT_DOCKER_IMAGE="node:22-alpine3.20"
STATUS_CHECK_RETRIES=10             # how many times to retry checking status (100ms wait) after starting or stopping a project

# Utility: List available commands and their descriptions.
list_commands() {  # args: none, reads: none, sets: none
	echo "Usage: $0 <command> [project] [options]"
	echo ""
	echo "# Available commands:"
	echo "   help                Show help"
	echo "   add                 Add a new (for now disabled) project (create its .env file)"
	echo "   remove              Remove a project (check for it being disabled, then delete its .env file)"
	echo "   list                List all projects"
	echo "   enable [project]    Install and enable project(s), run again to re-install"
	echo "   disable [project]   Disable and uninstall project(s)"
	echo "   start [project]     Start enabled project(s)"
	echo "   stop [project]      Stop project(s)"
	echo "   restart [project]   Restart enabled project(s)"
	echo "   status [project]    Show status (enabled + running) and extended status with explicit project name"
	echo "   logs <project>      Show logs for one project"
	echo "   update [project]    Update project(s) using git, with no project specified, self-update is run at first"
	echo "   self-update         Update manager script"
	echo ""
	echo "# Options and parameters:"
	echo "   -q, --quiet                 Suppress prompts (for automation)"
	echo "   -f, --force                 Force actions without confirmation prompts (use with caution)"
	echo "   -s, --no-status-check       Don't retry checking status after starting or stopping a project"
	echo "   -n, --number-of-lines <N>   Show N log lines or use 'f' (follow) for 'logs' command (default: follow / for all projects $LOG_LINES)"
}

# Command: Print detailed help and workflow information for JeredMgr.
show_help() {  # args: none, reads: none, sets: none
	echo "Welcome to JeredMgr, a tool that helps you install, run, and update multiple projects"
	echo "using Docker containers, systemd services, or custom scripts!"
	echo ""
	list_commands
	echo ""
	echo "# When installing (enabling or updating) a project, JeredMgr will:"
	echo ""
	echo "- Look for a setup.sh script in the project path and run it."
	echo ""
	echo "- Type 'docker'"
	echo "   Link the <project-name>.docker-compose.yml file in the projects directory, chosen in the following order:"
	echo "   - Already existing regular file <project-name>.docker-compose.yml in the projects directory"
	echo "   - A docker-compose.yml file in the project path"
	echo "   - A docker-compose-default.yml file in the project path"
	echo "   - A valid <project-name>.docker-compose.yml link file in the projects directory"
	echo "   - Look for a Dockerfile in the project directory and create a <project-name>.docker-compose.yml file in the projects directory from that"
	echo "     with a comment '# Auto-generated by JeredMgr, will remove images on uninstall'"
	echo "   - Otherwise offer to create a Dockerfile in the project path"
	echo ""
	echo "- Type 'service'"
	echo "   Link the <project-name>.service file in the projects directory, chosen in the following order:"
	echo "   - Already installed regular file <project-name>.service in the projects directory"
	echo "   - A <project-name>.service file in the project path"
	echo "   - A default.service file in the project path"
	echo "   - A valid <project-name>.service link file in the projects directory"
	echo "   - Otherwise offer to create a <project-name>.service file in the projects directory"
	echo "   - A link to the <project-name>.service file will be created in /etc/systemd/system/"
	echo ""
	echo "# When running a project, JeredMgr will:"
	echo ""
	echo "- Type 'docker'"
	echo "  Run the project with \`docker compose -f <project-name>.docker-compose.yml --project-directory <project-path> up -d\` / \`... down\` etc."
	echo "  (Keep in mind: If a docker project is stopped, it does not automatically start again on reboot,"
	echo "   as \`docker compose ... down\` removes the container. That way, changes to the compose file automatically take effect.)"
	echo ""
	echo "- Type 'service'"
	echo "  Run the project with \`systemctl start <project-name>\` / \`... stop\` etc."
	echo "  (Keep in mind: If a service project is stopped, it automatically starts again on reboot,"
	echo "   as \`systemctl stop ...\` does not disable the service. Changes to the service file will only take effect with calling enable again or on a reboot.)"
	echo ""
	echo "- Type 'scripts'"
	echo "  Look for the following scripts in the project path and run them with the corresponding commands:"
	echo "  - start.sh"
	echo "  - stop.sh"
	echo "  - restart.sh (otherwise start.sh + stop.sh)"
	echo "  - status.sh"
	echo "  - logs.sh"
	echo ""
	echo "# When uninstalling a project, JeredMgr will:"
	echo ""
	echo "- Stop the project if running"
	echo ""
	echo "- Type 'docker'"
	echo "   Remove the docker container"
	echo "   If the docker-compose.yml file has the '# Auto-generated ...' comment, remove all docker images named <project-name>"
	echo ""
	echo "- Type 'service'"
	echo "   Delete the service file link from /etc/systemd/system/"
	echo "   Remove the service with \`systemctl daemon-reload\`"
	echo ""
	echo "- Type 'scripts'"
	echo "  Look for a uninstall.sh script in the project path and run it"
	echo ""
	echo "- The project with its .env file isn't deleted, so it can be re-enabled again later"
	echo ""
	echo "# When updating a project, JeredMgr will:"
	echo ""
	echo "- Look for an update.sh script in the project path and run it"
	echo ""
	echo "- Else:"
	echo "  - Update the project using git if it's a git repository"
	echo "  - Pull new images from the docker repositories if it's a docker project"
	echo ""
}

################################################################################
# Utility functions
################################################################################

# Utility: check if git is installed, otherwise exit
ensure_git_installed() {  # args: none, reads: none, sets: none
	if ! command -v git >/dev/null 2>&1; then
		echo "Error: git is not installed or not in PATH."
		exit 1
	fi
}

# Utility: return whether git is available in supplied path
check_git_path() {  # args: $path, reads: none, sets: none
	local path="$1"
	if ! $(git -C "$path" rev-parse --is-inside-work-tree >/dev/null 2>&1); then
		return 1
	fi
	return 0
}

# Utility: check whether upstream commit equals local commit without fetching
check_git_upstream() {  # args: $path, reads: none, sets: none
	local path="$1"
	local upstream_ref=$(git -C "$path" rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null) || { echo "No upstream configured" 1>&2; return 1; }
	local remote_name=$(echo "$upstream_ref" | cut -d'/' -f1)
	local remote_branch=$(echo "$upstream_ref" | cut -d'/' -f2-)
	local upstream_commit=$(git -C "$path" ls-remote --refs -q "$remote_name" "refs/heads/$remote_branch" | awk '{print $1}')
	if [ -z "$upstream_commit" ]; then
		echo "No upstream commit found" 1>&2
		return 1
	fi
	local local_commit=$(git -C "$path" rev-parse HEAD 2>/dev/null)
	if [ "$upstream_commit" = "$local_commit" ]; then
		return 0
	else
		return 2
	fi
}	


# Utility: prompt user for global GitHub PAT and store it in $PAT_FILE
prompt_global_pat() {  # args: none, reads: none, sets: pat
	if [ ! -f "$PAT_FILE" ] || [ ! -s "$PAT_FILE" ]; then
		if $option_quiet; then
			echo "Please run once without -q to provide a global GitHub PAT."
			return 1
		else
			read -p "Enter your global GitHub PAT: " pat
			echo "$pat" > "$PAT_FILE"
		fi
	fi
	global_pat=$(<"$PAT_FILE")
}

# Utility: get full repository URL including possible PAT from plain URL without PAT
get_repo_pat_url() {  # args: $repo_url $use_global_pat $local_pat, reads: $global_pat, sets: none
	local repo_url="$1"
	local use_global_pat="$2"
	local local_pat="$3"
	local pat=""

	if ! echo "$repo_url" | grep -q "github.com" && ($use_global_pat || [ -n "$local_pat" ]); then
		echo "Warning: PAT authentication is configured, but the repository is not a GitHub repository (doesn't contain 'github.com' in the URL)."
		return 1
	fi

	if $use_global_pat; then
		if ! prompt_global_pat; then return 1; fi
		# Check if global_pat is empty
		if [ -z "$global_pat" ]; then
			echo "Please provide a global GitHub PAT or reconfigure the project to use a different authentication method!"
			return 1
		fi
		pat="$global_pat"
	else
		pat="$local_pat"
	fi
	if [ -n "$pat" ]; then
		# Insert PAT into repository URL
		repo_url="${repo_url/github.com/${pat}@github.com}"
	else
		# No global PAT, local PAT is empty, assume either public repo or git-globally configured authentication
		echo "$repo_url"
	fi  
}


# Utility: read value from .env file
read_env_value() {  # args: $key, reads: env_file, sets: none
	local key="$1"
	grep "^${key}=" "$env_file" | cut -d'#' -f1 | cut -d'=' -f2
}

# Utility: write or update a value in .env file
write_env_value() {  # args: $key $value, reads: $env_file, sets: none
	local key="$1"
	local value="$2"
	
	grep -q "^${key}=" "$env_file" \
		&& sed -i "s|^${key}=.*|${key}=${value}|" "$env_file" \
		|| echo "${key}=${value}" >> "$env_file"
}

# Utility: load project values
load_project_values() {  # args: $project_name, reads: none, sets: $project_name $env_file $enabled $repo_url $path $use_global_pat $local_pat $type $type_checked
	project_name="$1"
	env_file="$PROJECTS_DIR/$project_name.env"
	if [ ! -f "$env_file" ]; then
		echo "Project '$project_name' not found."
		exit 1
	fi

	enabled=$(read_env_value "ENABLED")
	if ! $enabled; then  # force to boolean
		enabled=false
	fi
	repo_url=$(read_env_value "REPO_URL")
	path=$(read_env_value "PATH")
	use_global_pat=$(read_env_value "USE_GLOBAL_PAT")
	if ! $use_global_pat; then  # force to boolean
		use_global_pat=false
	fi
	local_pat=$(read_env_value "LOCAL_PAT")
	type=$(read_env_value "TYPE")

	# Check if type is one of the supported values
	type_checked=false  # certain to be boolean
	if [ "$type" = "docker" ] || [ "$type" = "service" ] || [ "$type" = "scripts" ]; then
		type_checked=true
	fi
}

# Utility: generate compose file content
generate_compose_file_content() {  # args: none, reads: $project_name $path, sets: none
	echo -e "# Auto-generated by JeredMgr, will remove images on uninstall"
	echo -e "services:"
	echo -e "  $project_name:"
	echo -e "    build: $path"
	echo -e "    container_name: $project_name"
}

# Utility: Ensure a canonical symlinked compose file exists for the project, generating or linking as needed.
select_compose_file() {  # args: none, reads: $project_name $path, sets: $compose_file
	compose_file="$PROJECTS_DIR/$project_name.docker-compose.yml"
	# If already a regular file itself (not a symlink), use it
	if [ -f "$compose_file" ] && [ ! -L "$compose_file" ]; then
		echo "Using compose file: $compose_file"
	fi
	# Otherwise, try to find the best compose file to link to
	if [ -f "$path/docker-compose.yml" ]; then
		echo "Linking compose file: $path/docker-compose.yml"
		ln -sf "$path/docker-compose.yml" "$compose_file"
	elif [ -f "$path/docker-compose-default.yml" ]; then
		echo "Linking compose file: $path/docker-compose-default.yml"
		ln -sf "$path/docker-compose-default.yml" "$compose_file"
	elif [ -f "$compose_file" ]; then
		# Already exists as a link file
		echo "Keeping linked compose file: $(readlink -f "$compose_file")"
	elif [ -f "$path/Dockerfile" ]; then
		# Generate a compose file in projects dir
		echo "┌── GENERATING FILE: $compose_file ───"
		local compose_content=$(generate_compose_file_content)
		echo -e "$compose_content" > "$compose_file"  # write to file
		echo -e "$compose_content" | sed 's/^/│ /'
		echo "└─── $compose_file ───────────────────"
		echo "Using generated compose file: $compose_file"
	else
		if ! $option_quiet && prompt_yes_no "No compose file or Dockerfile found. Generate a Dockerfile in $path?"; then
			local dockerfile="$path/Dockerfile"
			echo "┌── GENERATING FILE: $dockerfile ───"
			local dockerfile_content=""
			dockerfile_content+="FROM $DEFAULT_DOCKER_IMAGE\n"
			dockerfile_content+="WORKDIR /usr/src/app\n"
			dockerfile_content+="RUN corepack enable\n"
			dockerfile_content+="COPY . .\n"
			suggested_entrypoint="node index.js"
			if [ -f "$path/yarn.lock" ] || grep -q -s "packageManager: 'yarn" "$path/package.json"; then
				suggested_entrypoint="yarn start"
				dockerfile_content+="RUN yarn init -2\n"
				dockerfile_content+="RUN yarn install\n"
			elif [ -f "$path/package.json" ]; then
				suggested_entrypoint="npm start"
				dockerfile_content+="RUN npm init -y\n"
				dockerfile_content+="RUN npm install\n"
			fi
			echo -e "$dockerfile_content" > "$dockerfile"  # write to file
			echo -e "$dockerfile_content" | sed 's/^/│ /'
			dockerfile_content=""
			read -p "> Entrypoint (e.g. $suggested_entrypoint): " entrypoint
			dockerfile_content+="ENTRYPOINT [\"${entrypoint// /\", \"}\"]\n"
			echo -e "$dockerfile_content" >> "$dockerfile"  # append to file
			echo -e "$dockerfile_content"
			echo "└─── $dockerfile ────────────────────"
			if prompt_yes_no "Do you want to edit the Dockerfile?"; then
				${EDITOR:-vi} "$dockerfile"
			fi
			# Now generate compose file
			echo "┌── GENERATING FILE: $compose_file ───"
			local compose_content=$(generate_compose_file_content)
			echo -e "$compose_content" > "$compose_file"  # write to file
			echo -e "$compose_content" | sed 's/^/│ /'
			echo "└─── $compose_file ───────────────────"
			if prompt_yes_no "Do you want to edit the docker compose file?"; then
				${EDITOR:-vi} "$compose_file"
			fi
			echo "Using generated compose file: $compose_file"
		else
			$option_quiet && echo "To generate a Dockerfile, run this command without -q."
			compose_file=""
			return 1
		fi
	fi
}

# Utility: check if the compose file (link or file) exists for the project
check_compose_file() {  # args: none, reads: $project_name, sets: $compose_file
	compose_file="$PROJECTS_DIR/$project_name.docker-compose.yml"
	if [ ! -f "$compose_file" ]; then
		return 1
	fi
}

# Utility: Ensure a canonical symlinked service file exists for the project, generating or linking as needed.
select_service_file() {  # args: none, reads: $project_name $path, sets: $service_file
	service_file="$PROJECTS_DIR/$project_name.service"
	# If already a regular file itself (not a symlink), use it
	if [ -f "$service_file" ] && [ ! -L "$service_file" ]; then
		echo "Using service file: $service_file"
	fi
	# Otherwise, try to find the best service file to link to
	if [ -f "$PROJECTS_DIR/$project_name.service" ]; then
		echo "Linking service file: $PROJECTS_DIR/$project_name.service"
		ln -sf "$PROJECTS_DIR/$project_name.service" "$service_file"
	elif [ -f "$path/default.service" ]; then
		echo "Linking service file: $path/default.service"
		ln -sf "$path/default.service" "$service_file"
	elif [ -f "$service_file" ]; then
		# Already exists as a link file
		echo "Keeping linked service file: $(readlink -f "$service_file")"
	else
		if ! $option_quiet && prompt_yes_no "No service file found. Generate one?"; then
			local servicefile="$PROJECTS_DIR/$project_name.service"
			echo "┌── GENERATING FILE: $servicefile ───"
			local service_content=""
			service_content+="# Auto-generated by JeredMgr\n"
			service_content+="[Unit]\n"
			service_content+="Description=$project_name (managed by JeredMgr)\n"
			service_content+="After=network.target\n"
			service_content+="\n"
			service_content+="[Service]\n"
			service_content+="Type=simple\n"
			service_content+="User=$USER\n"
			service_content+="WorkingDirectory=$path\n"
			echo -e "$service_content" > "$servicefile"  # write to file
			echo -e "$service_content" | sed 's/^/│ /'
			service_content=""
			local startcmd
			read -p "> Start command (absolute or relative to $path): " startcmd
			service_content+="ExecStart=$startcmd\n"
			service_content+="Restart=always\n"
			while true; do
				read -p "> New environment variable (type as 'KEY=value', leave blank to finish): " service_envvar
				if [ -z "$service_envvar" ]; then
					break
				fi
				service_content+="Environment=\"$service_envvar\"\n"
			done
			service_content+="\n"
			service_content+="[Install]\n"
			service_content+="WantedBy=multi-user.target\n"
			echo -e "$service_content" >> "$servicefile"  # append to file
			echo -e "$service_content" | sed 's/^/│ /'
			echo "└─── $servicefile ───────────────────"
			if prompt_yes_no "Do you want to edit the service file?"; then
				${EDITOR:-vi} "$servicefile"
			fi
			echo "Linking service file: $servicefile"
			ln -sf "$servicefile" "$service_file"
		else
			$option_quiet && echo "To generate a service file, run this command without -q."
			service_file=""
			return 1
		fi
	fi
}

# Utility: check if the service file (link or file) exists for the project and the systemd service link points to it
check_service_file() {  # args: none, reads: $project_name, sets: $service_file
	service_file="$PROJECTS_DIR/$project_name.service"
	service_link="/etc/systemd/system/$project_name.service"
	if [ ! -f "$service_file" ] || [ "$(readlink -f "$service_link")" != "$service_file" ]; then
		return 1
	fi
}


# Utility: Prompt the user for a yes/no answer and return 0 for yes, 1 for no.
prompt_yes_no() {  # args: $prompt, reads: none, sets: none
	local prompt="$1"
	while true; do
		local yn
		read -n 1 -p "$prompt (y/n): " yn
		case $yn in
			[Yy]*) return 0;;
			[Nn]*) return 1;;
			*) echo "Please answer y or n.";;
		esac
	done
}

# Utility: Check if a file is executable
check_executable() {  # args: $file, reads: none, sets: none
	local file="$1"
	if [ ! -x "$file" ]; then
		if ! $option_quiet && prompt_yes_no "File '$file' is not executable. Make it executable?"; then
			chmod +x "$file"
		else
			return 1
		fi
	fi
}

lasttitle=""
# Utility: Start a pass-through progress indicator
startprogress() {   # args: $title, reads: none, sets: $lasttitle
	lasttitle=$1
	echo "$1"
}
lastoutput=""
# Utility: Pass-through the current line of output from a command
showprogress() {   # args: $command $args..., reads: none, sets: $lastoutput
	lastoutput=""
	local prevlen=0

    local fifo=$(mktemp -u)
    mkfifo "$fifo"
    "$@" &> "$fifo" &  # in background
    local cmd_pid=$!

	while IFS= read -r line; do
		curlen=${#line}
		[[ $curlen -lt $prevlen ]] && printf "\r%-${prevlen}s"
		printf "\r$line"
		prevlen=$curlen
		lastoutput+="$line"$'\n'
	done < "$fifo"

	wait "$cmd_pid"
	local retval=$?

	printf "\r%-${prevlen}s\r"
	return $retval
}
# Utility: End a pass-through progress indicator
endprogress() {   # args: $statustext, reads: none, sets: $lasttitle
	printf "\e[A"  # cursor up
	echo "$lasttitle" "$1"
	lasttitle=""
}

# Utility: Run script
run_script() {  # args: $script, reads: $path, sets: none
	local script="$1"
	if ! check_executable "$path/$script"; then
		echo "Script '$path/$script' is not executable, skipping."
	else
		echo "Running $path/$script"
		"$path/$script" || { retval=$?; echo "Script $script failed with exit code $retval" 1>&2; return $retval; }
	fi
}

# Utility: Confirm for all projects
confirm_all() {  # args: $verb, reads: none, sets: none
	if $option_quiet; then return 0; fi
	local verb="$1"
	read -p "Are you sure you want to $verb ALL projects? (y/n): " confirm
	[ "$confirm" = "y" ] || { echo "Cancelled."; exit 0; }
}

# Utility: loop through projects
for_each_project() {  # args: $project_name $action, reads: none, sets: none
	local project_name="$1"
	shift
	local action="$1"
	local all_success=true

	if [ -n "$project_name" ]; then
		local env_file="${PROJECTS_DIR}/${project_name}.env"
		if [ -f "$env_file" ]; then
			if [ "$action" != "list" ]; then
				echo "###   ${action^^} PROJECT:  $project_name   ###"
			fi
			${action}_project "$env_file" "$project_name" || all_success=false
		else
			echo "Project '$project_name' not found."
		fi
	else
		local is_first=true
		for env_file in "$PROJECTS_DIR"/*.env; do
			local project_name=$(basename "$env_file" .env)
			if [ "$action" != "list" ]; then
				if ! $is_first; then
					echo "----------------------------------------"
				fi
				is_first=false
				echo "###   ${action^^} PROJECT:  $project_name   ###"
			fi
			if [ ! -f "$env_file" ]; then
				echo "Invalid project file '$env_file'."
				all_success=false
				continue
			fi
			${action}_project "$env_file" "$project_name" || all_success=false
		done
	fi
	if ! $all_success; then return 1; fi
}

################################################################################
# Commands
################################################################################

# Command: Add a new project by prompting the user and creating a .env file.
add_project() {  # args: none, reads: none, sets: $project_name $env_file $owner $repo $use_global_pat $local_pat $path $type $repo_url $repo_pat_url
	if $option_quiet; then
		echo "Command 'add' cannot be called with --quiet." 1>&2
		return 1
	fi

	read -p "Project name: " project_name
	# Validate project name format
	if ! [[ "$project_name" =~ ^[a-z_][a-z_0-9]*$ ]]; then
		echo "Error: Project name must start with a lowercase letter or underscore and contain only lowercase letters, numbers, and underscores." 1>&2
		return 1
	fi
	env_file="${PROJECTS_DIR}/${project_name}.env"
	if [ -f "$env_file" ]; then
		echo "Error: Project already exists." 1>&2
		return 1
	fi

	read -p "GitHub owner: " owner
	read -p "GitHub repository name: " repo
	prompt_yes_no "Use global GitHub PAT?" && use_global_pat=true || use_global_pat=false
	local_pat=""
	if ! $use_global_pat; then
		read -p "Project-specific GitHub PAT (leave blank to use no PAT): " local_pat
	fi
	read -p "Project path: " path
	read -p "Project type (docker/docker_compose/service): " type

	repo_url="https://github.com/${owner}/${repo}.git"

	{
		echo "ENABLED=false"
		echo "REPO_URL=$repo_url"
		echo "PATH=$path"
		echo "USE_GLOBAL_PAT=$use_global_pat"
		echo "LOCAL_PAT=$local_pat"
	} > "$env_file"

	echo "Successfully added project '$project_name'."
	echo "You can now enable and install it with '$0 enable $project_name'."
}

# Command: Remove a project by deleting the .env file.
remove_project() {  # args: $project_name, reads: $env_file $project_name $enabled, sets: $env_file
	load_project_values "$1"
	if $enabled; then
		echo "Project '$project_name' is enabled, please disable it first."
		return 1
	fi
	if ! $option_force && ! prompt_yes_no "Are you sure you want to remove project '$project_name'?"; then
		echo "Cancelled."
		return
	fi
	rm -f "$env_file"
	rm -f "$PROJECTS_DIR/$project_name.docker-compose.yml"
	rm -f "$PROJECTS_DIR/$project_name.docker-compose.yml.bak"
	rm -f "$PROJECTS_DIR/$project_name.docker-compose.yml.bak2"
	rm -f "$PROJECTS_DIR/$project_name.service"
	echo "Successfully removed project '$project_name'."
}

# Command: List a single project with its enabled status and path.
list_project() {  # args: $project_name, reads: $enabled $project_name $path, sets: none
	load_project_values "$1"
	echo "${enabled/true/✓}${enabled/false/✗} $project_name: $path"
}

# Utility: Run setup.sh if present and perform type-specific install/setup logic for the project.
run_install() {  # args: none, reads: $repo_url $use_global_pat $local_pat $path $type $project_name, sets: none
	# check if type is supported
	if ! $type_checked; then
		echo "Unknown or unsupported type '$type', skipping install." 1>&2
		return 1
	fi

	# if path does not exist or is empty, clone the repository
	if [ ! -d "$path" ] || [ -z "$(ls -A "$path" 2>/dev/null)" ]; then
		repo_pat_url=$(get_repo_pat_url "$repo_url" "$use_global_pat" "$local_pat") || { echo "Could not get repository PAT URL." 1>&2; return 1; }
		echo "Cloning $repo_url $([ "$repo_url" != "$repo_pat_url" ] && echo "using PAT") into $path ..."
		git clone "$repo_pat_url" "$path" || { echo "Clone failed. Check credentials and repository access." 1>&2; return 1; }
		did_clone=true
	fi

	did_run_setup=false
	# run setup.sh if exists
	if [ -f "$path/setup.sh" ]; then
		run_script "setup.sh" || return 1;
		did_run_setup=true
	fi

	# run type-specific install/setup logic
	case "$type" in
		docker)
			if ! select_compose_file; then
				echo "No docker compose file could be determined."
				return 1
			fi
			echo "Building possible docker images ..."
			docker compose -f "$compose_file" --project-directory "$path" build
			;;
		service)
			if ! select_service_file; then
				echo "No service file could be determined."
				return 1
			fi

			service_link="/etc/systemd/system/$project_name.service"
			if [ -f "$service_link" ] && [ "$(readlink -f "$service_link")" != "$service_file" ]; then
				echo "A service file already exists at $service_link, cannot install $project_name." 1>&2
				return 1
			fi
			if ! [ -L "$service_link" ]; then
				ln -sf "$service_file" "$service_link" || { echo "Failed to link service file $service_link to $service_file" 1>&2; return 1; }
				echo "Linked service file $service_link to $service_file"
			else
				echo "Service file $service_link already linked to $service_file"
			fi

			echo "Reloading systemd daemon ..."
			systemctl daemon-reload
			;;
		scripts)
			if ! $did_run_setup; then
				echo "No setup.sh script found in $path, only setting ENABLED=true."
			fi
			;;
	esac
}

# Command: Enable a project by running install/setup and setting ENABLED=true in the .env file.
enable_project() {  # args: $project_name, reads: $env_file, sets: none
	load_project_values "$1"
	if ! run_install; then
		echo "Install failed, ${enabled/true/disabling project}${enabled/false/project remains disabled}."
		write_env_value "ENABLED" "false"
		return
	fi
	write_env_value "ENABLED" "true"
	echo "Successfully enabled project '$project_name'."
	echo "You can now start it with '$0 start $project_name'."
}

# Command: Disable and uninstall a project, performing type-specific cleanup and setting ENABLED=false.
disable_project() {  # args: $project_name, reads: $env_file $type $path, sets: none
	load_project_values "$1"
	if ! $enabled; then
		echo "Already disabled, skipping."
		return
	fi
	if ! $type_checked; then
		echo "Unknown or unsupported type '$type', skipping uninstall."
	else
		case "$type" in
			docker)
				if ! check_compose_file; then
					echo "No valid docker compose file found, possibly already uninstalled."
				else
					if grep -q '# Auto-generated by JeredMgr, will remove images on uninstall' "$compose_file"; then
						echo "Stopping possibly running docker containers and removing images ..."
						docker compose -f "$compose_file" --project-directory "$path" down --rmi all
						if [ -f "$compose_file" ]; then
							# Check if compose file was auto-generated and matches current content
							if [ $(cat "$compose_file") = $(generate_compose_file_content) ]; then
								rm "$compose_file"
							else
								mv "$compose_file.bak" "$compose_file.bak2" 2>/dev/null
								mv "$compose_file" "$compose_file.bak"
								echo "Created backup of compose file to $compose_file.bak"
							fi
						fi
					else
						echo "Stopping possibly running docker containers ..."
						docker compose -f "$compose_file" --project-directory "$path" down
					fi
				fi
				;;
			service)
				if ! check_service_file; then
					if systemctl status "$project_name" > /dev/null 2>&1; then
						echo "Warning: No valid project service file found, but found systemd service '$project_name'! There might be another service with the same name!"
					else
						echo "No valid service file and no systemd service found, possibly already uninstalled."
					fi
				else
					echo "Stopping systemd service '$project_name' ..."
					systemctl stop "$project_name"
					rm -f "$service_link"
					echo "Removed service file link $service_link"
				fi
				echo "Reloading systemd daemon ..."
				systemctl daemon-reload
				;;
			scripts)
				if [ -f "$path/uninstall.sh" ]; then
					run_script "uninstall.sh" || return 1;
				else
					echo "No uninstall.sh script found in $path, only setting ENABLED=false."
				fi
				;;
		esac
	fi
	write_env_value "ENABLED" "false"
	echo "Successfully $($type_checked && echo "uninstalled and disabled" || echo "disabled") project '$project_name'."
}

# Utility: Get the running status of a project: Yes, No, Unknown.
get_running_status() {  # args: none, reads: $type $path $project_name, sets: none
	case "$type" in
		docker)
			if ! check_compose_file; then
				echo "Unknown"
				return
			else
				running=$(docker compose -f "$compose_file" --project-directory "$path" ps --services --filter status=running 2>/dev/null) || running=""
				[ -n "$running" ] && echo "Yes" || echo "No"
			fi
			;;
		service)
			if ! check_service_file; then
				echo "Unknown"
				return
			else
				active=$(systemctl is-active "$project_name" 2>/dev/null) || active=""
				[ "$active" = "active" ] && echo "Yes" || echo "No"
			fi
			;;
		scripts)
			echo "Unknown"
			;;
	esac
}


# Command: Start a project if enabled, using the appropriate method for its type.
start_project() {  # args: $project_name, reads: $enabled $type $path $project_name, sets: none
	load_project_values "$1"
	if ! $enabled; then
		echo "Not enabled, skipping start."
		return
	fi
	if ! $type_checked; then
		echo "Unknown or unsupported type '$type', skipping start."
		return 1
	fi
	local running_status=$(get_running_status)
	if [ "$running_status" = "Yes" ] && ! $option_force && ($option_quiet || ! prompt_yes_no "Project seems to be running. Trigger start anyway?"); then
		echo "Already running, skipping start."
		return
	fi
	local check_status=false
	case "$type" in
		docker)
			if ! check_compose_file; then
				echo "No valid docker compose file found, cannot start."
				return 1
			fi
			docker compose -f "$compose_file" --project-directory "$path" up -d
			check_status=true
			;;
		service)
			if ! check_service_file; then
				echo "No valid service file found, cannot start."
				return 1
			fi
			systemctl start "$project_name"
			check_status=true
			;;
		scripts)
			if [ -f "$path/start.sh" ]; then
				run_script "start.sh" || return 1;
			else
				echo "No start.sh script found in $path."
				return 1
			fi
			;;
	esac

	if ! $check_status; then
		echo "Project started '$project_name'."
		return
	fi

	local i=0
	local max_retries=$STATUS_CHECK_RETRIES
	if $option_no_status_check; then
		max_retries=0
	fi
	while [ $i -le $max_retries ]; do
		[ $i -gt 0 ] && sleep 0.1
		running_status=$(get_running_status)
		if [ "$running_status" = "Yes" ]; then
			echo "Successfully started project '$project_name'."
			return
		fi
		((i++))
	done
	if [ "$running_status" = "No" ]; then
		echo "Failed to start project '$project_name', not running after $(((i - 1) * 100))ms timeout."
	else
		echo "Running status unknown for project '$project_name'."
	fi
	return 1
}

# Command: Stop a project using the appropriate method for its type.
stop_project() {  # args: $project_name, reads: $type $path $project_name, sets: none
	load_project_values "$1"
	if ! $type_checked; then
		echo "Unknown or unsupported type '$type', skipping stop."
		return 1
	fi
	local running_status=$(get_running_status)
	if [ "$running_status" = "No" ] && ! $option_force && ($option_quiet || ! prompt_yes_no "Project seems to be stopped. Trigger stop anyway?"); then
		echo "Already stopped, skipping stop."
		return
	fi
	local check_status=false
	case "$type" in
		docker)
			if ! check_compose_file; then
				echo "No valid docker compose file found, cannot stop."
				return 1
			fi
			docker compose -f "$compose_file" --project-directory "$path" down
			check_status=true
			;;
		service)
			if ! check_service_file; then
				echo "No valid service file found, cannot stop."
				return 1
			fi
			systemctl stop "$project_name"
			check_status=true
			;;
		scripts)
			if [ -f "$path/stop.sh" ]; then
				run_script "stop.sh" || return 1;
			else
				echo "No stop.sh script found in $path."
				return 1
			fi
			;;
	esac

	if ! $check_status; then
		echo "Project stopped '$project_name'."
		return
	fi

	local i=0
	local max_retries=$STATUS_CHECK_RETRIES
	if $option_no_status_check; then
		max_retries=0
	fi
	while [ $i -le $max_retries ]; do
		[ $i -gt 0 ] && sleep 0.1
		running_status=$(get_running_status)
		if [ "$running_status" = "No" ]; then
			echo "Successfully stopped project '$project_name'."
			return
		fi
		i=$((i + 1))
	done
	if [ "$running_status" = "Yes" ]; then
		echo "Failed to stop project '$project_name', still running after $(((i - 1) * 100))ms timeout."
	else
		echo "Running status unknown for project '$project_name'."
	fi
	return 1
}

# Command: Restart a project if enabled, using the appropriate method for its type.
restart_project() {  # args: $project_name, reads: $enabled $type $path $project_name, sets: none
	load_project_values "$1"
	if ! $enabled; then
		echo "Not enabled, skipping restart."
		return
	fi
	if ! $type_checked; then
		echo "Unknown or unsupported type '$type', skipping restart."
		return 1
	fi
	case "$type" in
		docker)
			if ! check_compose_file; then
				echo "No valid docker compose file found, cannot restart."
				return 1
			fi
			docker compose -f "$compose_file" --project-directory "$path" down
			docker compose -f "$compose_file" --project-directory "$path" up -d
			;;
		service)
			if ! check_service_file; then
				echo "No valid service file found, cannot restart."
				return 1
			fi
			systemctl restart "$project_name"
			;;
		scripts)
			if [ -f "$path/restart.sh" ]; then
				run_script "restart.sh" || return 1;
			elif [ -f "$path/stop.sh" ] && [ -f "$path/start.sh" ]; then
				run_script "stop.sh" || return 1;
				run_script "start.sh" || return 1;
			else
				echo "No restart.sh or start.sh + stop.sh scripts found in $path."
				return 1
			fi
			;;
	esac
	echo "Successfully restarted."
}

# Command: Show the status of a project, including enabled/running state and git status.
status_project() {  # args: $project_name, reads: $enabled $type $path $project_name $repo_url $use_global_pat $local_pat $all_projects, sets: none
	load_project_values "$1"
	echo "Enabled: ${enabled/true/✓}${enabled/false/✗}"
	if ! $type_checked; then
		echo "Unknown or unsupported type '$type', skipping status."
		return 1
	fi
	case "$type" in
		docker)
			running_status=$(get_running_status)
			echo "Running: $running_status"
			if ! check_compose_file; then
				echo "Docker compose file: Not found"
			else
				echo "Docker compose file: $compose_file$([ -L "$compose_file" ] && echo " (→ $(readlink -f "$compose_file"))")"
			fi
			;;
		service)
			running_status=$(get_running_status)
			echo "Running: $running_status"
			if ! check_service_file; then
				echo "Service file: Not found"
			else
				echo "Service file: $service_file$([ -L "$service_file" ] && echo " (→ $(readlink -f "$service_file"))")"
			fi
			;;
		scripts)
			if [ -f "$path/status.sh" ]; then
				run_script "status.sh" || return 1;
			else
				echo "No status.sh script found in $path."
			fi
			;;
	esac
	echo "Path: $path"
	echo "Repository: $repo_url"
	if $use_global_pat; then
		echo "Authentication: Using global PAT"
	else if [ -n "$local_pat" ]; then
		echo "Authentication: Using project-specific PAT"
	else
		echo "Authentication: Public repository or globally configured"
	fi
	# Check for git updates
	echo -n "Git status: "
	if check_git_path "$path"; then
		local error_msg=$(check_git_upstream "$path" 2>&1)
		if [ $? -eq 0 ]; then
			echo "Up to date$([ $type = "docker" ] && echo " (There might be new docker images available though)")"
		else
			echo "${error_msg:-Update available}"
		fi
	else
		echo "Git repository not set up!"
	fi

	if ! $all_projects && ( [ "$type" = "docker" ] || [ "$type" = "service" ] ); then
		echo ""
		case "$type" in
			docker)
				docker compose -f "$compose_file" --project-directory "$path" ps
				;;
			service)
				systemctl status "$project_name" --no-pager -n 0
				;;
		esac
	fi
}

# Command: Show logs for a project using the appropriate method for its type.
logs_project() {  # args: $project_name, reads: $type $path $project_name $all_projects $parameter_lines, sets: none
	load_project_values "$1"
	if ! $type_checked; then
		echo "Unknown or unsupported type '$type', skipping logs."
		return 1
	fi
	case "$type" in
		docker)
			if ! check_compose_file; then
				echo "No valid docker compose file found, cannot show logs."
				return 1
			fi
			docker compose -f "$compose_file" --project-directory "$path" logs $(! $all_projects && [ "$parameter_lines" = "f" ] && echo "-f" || echo "-n $parameter_lines")
			;;
		service)
			if ! check_service_file; then
				echo "No valid service file found, cannot show logs."
				return 1
			fi
			journalctl -u "$project_name" $(! $all_projects && [ "$parameter_lines" = "f" ] && echo "-f" || echo "-n $parameter_lines")
			;;
		scripts)
			if [ -f "$path/logs.sh" ]; then
				run_script "logs.sh" || return 1;
			else
				echo "No logs.sh script found."
				return 1
			fi
			;;
	esac
}

# Command: Update the git repository for a project.
update_git_repo() {
	if ! check_git_path "$path"; then
		echo "Path is not a git repository! Skipping git repository update."
		return
	fi
	repo_pat_url=$(get_repo_pat_url "$repo_url" "$use_global_pat" "$local_pat")
	echo "Fetching updates ..."
	git -C "$path" fetch --quiet
	local previous_hash=$(git -C "$path" rev-parse --short HEAD 2>/dev/null)
	local local_branch=$(git -C "$path" rev-parse --abbrev-ref HEAD 2>/dev/null)
	local upstream_ref=$(git -C "$path" rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null) || { echo "No upstream configured" 1>&2; return 1; }
	local remote_name=$(echo "$upstream_ref" | cut -d'/' -f1)
	local remote_branch=$(echo "$upstream_ref" | cut -d'/' -f2-)
	local behind=$(git -C "$path" rev-list --count "$local_branch..$upstream_ref" 2>/dev/null)
	if [ "$behind" -eq 0 ]; then
		echo "Git repository is up to date"
	else
		echo "Updating git repository ($behind commits behind) ..."
		startprogress ""
		showprogress git -C "$path" pull "$repo_pat_url" || {
			endprogress "Update failed with exit code $?!"
			echo "$lastoutput"
			return 1
		}
		local current_hash=$(git -C "$path" rev-parse --short HEAD 2>/dev/null)
		endprogress "Successfully updated git repository from $previous_hash to $current_hash"
	fi
}

dangling_docker_images=""
dangling_docker_hashes=""
# Utility: Update docker images if the project is a docker project.
update_docker_images() {
	if [ $type = "docker" ] && check_compose_file; then
		# pull images separately to track whether something was updated instead of `docker compose pull`
		local images=$(docker compose -f "$compose_file" --project-directory "$path" config | grep -E '^[ \t]+image: ' | awk '{ sub(/^[ \t]+image: +/, ""); sub(/[ \t].*$/, ""); print }')
		if [ -z "$images" ]; then
			echo "No images to possibly update found in docker compose file."
		else
			echo "Checking for new docker images:"
			local updated=0
			local new_dangling=""
			local new_dangling_hashes=""
			for image in "${images[@]}"; do
				startprogress "  - ${image}:"
				showprogress docker image pull "$image" || {
					endprogress "Update failed with exit code $?!"
					echo "$lastoutput"
					return 1
				}
				if echo "$lastoutput" | grep -q "Status: Image is up to date"; then
					endprogress "Already up to date"
				else
					endprogress "Updated successfully"
					((updated++))
				fi
				new_dangling+="$(docker images --format "  - {{.Repository}}:{{.Tag}} {{.ID}}" --filter "dangling=true" --filter "reference=${image%:*}")"$'\n'
				new_dangling_hashes+="$(docker images --format "{{.ID}}" --filter "dangling=true" --filter "reference=${image%:*}") "
			done
			if [ -n "$new_dangling_hashes" ]; then
				echo "Obsolete (dangling) images will be listed at the end of the update(s)."
				dangling_docker_images+="# $project_name:\n$new_dangling"
				dangling_docker_hashes+="$new_dangling_hashes"
			fi
			if [ $updated -ne 0 ]; then
				echo "Successfully updated $updated docker image(s)."
			else
				echo "All docker images already up to date."
			fi
		fi
	fi
}

# Command: Update a project by pulling from git, running install/setup, and restarting if successful.
update_project() {  # args: $project_name, reads: $path $repo_url $use_global_pat $local_pat $project_name, sets: none
	local running_status=$(get_running_status)

	load_project_values "$1"
	if [ -f "$path/update.sh" ]; then
		run_script "update.sh" || return 1;
	else
		update_git_repo || return 1
		update_docker_images || return 1
	fi

	if ! run_install; then
		echo "Post-update install failed, skipping restart." 1>&2
		return 1
	fi

	echo ""
	echo "Update complete."
	if [ "$running_status" = "Yes" ]; then
		echo "Restarting project after update ..."
		restart_project "$project_name" || return 1
	else
		echo "Project is not running, skipping restart."
	fi
}

# Command: Update the manager script itself from the remote repository.
self_update() {  # args: none, reads: none, sets: none
	if $option_internal_recursive; then
		echo "Successfully updated $0."
		return
	fi
	local tmp_file=$(mktemp)
	echo "Checking for script updates ..."
	curl -s -o "$tmp_file" "$SELFUPDATE_URL"
	if [ $? -ne 0 ]; then
		echo "Failed to download updated manager script."
		rm -f "$tmp_file" 2>/dev/null
		return 1
	fi

	if cmp -s "$tmp_file" "$0"; then
		echo "Manager script is already up to date."
		rm -f "$tmp_file" 2>/dev/null
	else
		echo "Updating manager script ..."
		mv -f "$tmp_file" "$0"
		chmod +x "$0"
		echo "Restarting ..."
		"$0" "${original_args[@]}" --internal-recursive
		exit $?
	fi
}

################################################################################    
# MAIN
################################################################################

original_args=("$@")

command=""
project_name=""
option_quiet=false
option_force=false
option_no_status_check=false
option_internal_recursive=false
parameter_lines="f"

exit_code=0

while [[ $# -gt 0 ]]; do
	case "$1" in
		-q|--quiet)
			option_quiet=true
			shift
			;;
		-f|--force)
			option_force=true
			shift
			;;
		-s|--no-status-check)
			option_no_status_check=true
			shift
			;;
		-n|--number-of-lines)
			if [ "$2" = "f" ] || [ "$2" = "follow" ]; then
				parameter_lines="f"
			elif [[ "$2" =~ ^[0-9]+$ ]]; then
				parameter_lines="$2"
			else
				echo "Error: Line count must be a number or 'f'/'follow'" 1>&2
				exit 1
			fi
			shift 2
			;;
		--internal-recursive)
			option_internal_recursive=true
			shift
			;;
		-*)
			echo "Unknown option: $1" 1>&2
			list_commands
			exit 1
			;;
		*)
			if [ -z "$command" ]; then
				command="$1"
			elif [ -z "$project_name" ]; then
				project_name="$1"
			else
				echo "Too many arguments: $1" 1>&2
				list_commands
				exit 1
			fi
			shift
			;;
	esac
done

if [ -z "$command" ]; then
	echo "Welcome to JeredMgr!"
	list_commands
	exit 1
fi

all_projects=$([ -z "$project_name" ] && echo "true" || echo "false")
mkdir -p "$PROJECTS_DIR"
ensure_git_installed

case $command in
	add)
		add_project || exit_code=$?
		;;
	remove)
		remove_project || exit_code=$?
		;;
	list)
		for_each_project "$project_name" "$command" || exit_code=$?
		;;
	enable)
		if $all_projects; then confirm_all "enable"; fi
		for_each_project "$project_name" "$command" || exit_code=$?
		;;
	disable)
		if $all_projects; then confirm_all "disable"; fi
		for_each_project "$project_name" "$command" || exit_code=$?
		;;
	start)
		if $all_projects; then confirm_all "start"; fi
		for_each_project "$project_name" "$command" || exit_code=$?
		;;
	stop)
		if $all_projects; then confirm_all "stop"; fi
		for_each_project "$project_name" "$command" || exit_code=$?
		;;
	restart)
		if $all_projects; then confirm_all "restart"; fi
		for_each_project "$project_name" "$command" || exit_code=$?
		;;
	status)
		for_each_project "$project_name" "$command" || exit_code=$?
		;;
	logs)
		if $all_projects; then confirm_all "show logs for"; fi
		for_each_project "$project_name" "$command" || exit_code=$?
		;;
	update)
		if $all_projects && ! $option_internal_recursive; then
			echo "###   SELF-UPDATE   ###"
			self_update || exit_code=$?
			echo ""
		fi
		for_each_project "$project_name" "$command" || exit_code=$?
		if [ -n "$dangling_docker_hashes" ]; then
			echo ""
			echo "###   OBSOLETE DOCKER IMAGES   ###"
			echo "The following dangling docker images were found:"
			echo "$dangling_docker_images"
			! $option_quiet && prompt_yes_no "Do you want to remove them now?" && docker rmi -f $dangling_docker_hashes || echo "You can remove them later using \`docker rmi -f ${dangling_docker_hashes% }\`"
		fi
		;;
	self-update)
		self_update || exit_code=$?
		;;
	*)
		echo "Unknown command: $command" 1>&2
		list_commands
		exit 1
		;;
esac

exit $exit_code
